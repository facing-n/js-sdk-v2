<!DOCTYPE html><html lang="en" style="font-size:16px"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" href="/demo/public/images/favicon.ico"><title>resources/releases.js</title><!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><script src="scripts/third-party/hljs.js" defer="defer"></script><script src="scripts/third-party/hljs-line-num.js" defer="defer"></script><script src="scripts/third-party/popper.js" defer="defer"></script><script src="scripts/third-party/tippy.js" defer="defer"></script><script src="scripts/third-party/tocbot.min.js"></script><script>var baseURL="/",locationPathname="",baseURL=(locationPathname=document.location.pathname).substr(0,locationPathname.lastIndexOf("/")+1)</script><link rel="stylesheet" href="styles/clean-jsdoc-theme.min.css"><svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none"><defs><symbol id="copy-icon" viewbox="0 0 488.3 488.3"><g><path d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z"/><path d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z"/></g></symbol><symbol id="search-icon" viewBox="0 0 512 512"><g><g><path d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z"/></g></g><g><g><path d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z"/></g></g></symbol><symbol id="font-size-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11.246 15H4.754l-2 5H.6L7 4h2l6.4 16h-2.154l-2-5zm-.8-2L8 6.885 5.554 13h4.892zM21 12.535V12h2v8h-2v-.535a4 4 0 1 1 0-6.93zM19 18a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"/></symbol><symbol id="add-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2z"/></symbol><symbol id="minus-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M5 11h14v2H5z"/></symbol><symbol id="dark-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2h.1A6.979 6.979 0 0 0 10 7zm-6 5a8 8 0 0 0 15.062 3.762A9 9 0 0 1 8.238 4.938 7.999 7.999 0 0 0 4 12z"/></symbol><symbol id="light-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 18a6 6 0 1 1 0-12 6 6 0 0 1 0 12zm0-2a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM11 1h2v3h-2V1zm0 19h2v3h-2v-3zM3.515 4.929l1.414-1.414L7.05 5.636 5.636 7.05 3.515 4.93zM16.95 18.364l1.414-1.414 2.121 2.121-1.414 1.414-2.121-2.121zm2.121-14.85l1.414 1.415-2.121 2.121-1.414-1.414 2.121-2.121zM5.636 16.95l1.414 1.414-2.121 2.121-1.414-1.414 2.121-2.121zM23 11v2h-3v-2h3zM4 11v2H1v-2h3z"/></symbol><symbol id="reset-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M18.537 19.567A9.961 9.961 0 0 1 12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10c0 2.136-.67 4.116-1.81 5.74L17 12h3a8 8 0 1 0-2.46 5.772l.997 1.795z"/></symbol><symbol id="down-icon" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"></path></symbol><symbol id="codepen-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M16.5 13.202L13 15.535v3.596L19.197 15 16.5 13.202zM14.697 12L12 10.202 9.303 12 12 13.798 14.697 12zM20 10.869L18.303 12 20 13.131V10.87zM19.197 9L13 4.869v3.596l3.5 2.333L19.197 9zM7.5 10.798L11 8.465V4.869L4.803 9 7.5 10.798zM4.803 15L11 19.131v-3.596l-3.5-2.333L4.803 15zM4 13.131L5.697 12 4 10.869v2.262zM2 9a1 1 0 0 1 .445-.832l9-6a1 1 0 0 1 1.11 0l9 6A1 1 0 0 1 22 9v6a1 1 0 0 1-.445.832l-9 6a1 1 0 0 1-1.11 0l-9-6A1 1 0 0 1 2 15V9z"/></symbol><symbol id="close-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 10.586l4.95-4.95 1.414 1.414-4.95 4.95 4.95 4.95-1.414 1.414-4.95-4.95-4.95 4.95-1.414-1.414 4.95-4.95-4.95-4.95L7.05 5.636z"/></symbol><symbol id="menu-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z"/></symbol></defs></svg></head><body class="dark" data-theme="dark"><div class="sidebar-container"><div class="sidebar" id="sidebar"><a href="/" class="sidebar-title sidebar-title-anchor">@nina-protocol/js-sdk</a><div class="sidebar-items-container"><div class="sidebar-section-title with-arrow" data-isopen="false" id="_0O3YiuusVCU80BYexLu_"><div>Modules</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="module-Account.html">Account</a></div><div class="sidebar-section-children"><a href="module-Exchange.html">Exchange</a></div><div class="sidebar-section-children"><a href="module-Hub.html">Hub</a></div><div class="sidebar-section-children"><a href="module-Post.html">Post</a></div><div class="sidebar-section-children"><a href="module-Release.html">Release</a></div><div class="sidebar-section-children"><a href="module-Search.html">Search</a></div><div class="sidebar-section-children"><a href="module-Subscription.html">Subscription</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="XQXdyJUZGv6LEeZCNU6PL"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="NinaClient.html">NinaClient</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="15ZawdpG98m0aRc5WmjbQ"><div>Global</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="global.html#init">init</a></div></div></div></div></div><div class="navbar-container" id="VuAckcnZhf"><nav class="navbar"><div class="navbar-left-items"></div><div class="navbar-right-items"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div><nav></nav></nav></div><div class="toc-container"><div class="toc-content"><span class="bold">On this page</span><div id="eed4d2a0bfd64539bb9df78095dec881"></div></div></div><div class="body-wrapper"><div class="main-content"><div class="main-wrapper"><section id="source-page" class="source-page"><header><h1 id="title" class="has-anchor">resources_releases.js</h1></header><article><pre class="prettyprint source lang-js"><code>import NinaClient from '../client';
import * as anchor from '@project-serum/anchor';
import {
  findOrCreateAssociatedTokenAccount,
  getUsdcBalance,
  createMintInstructions,
  uiToNative,
  decodeNonEncryptedByteArray,
  getConfirmTransaction,
  TOKEN_PROGRAM_ID,
} from '../utils';
import Hub from './hubs';
import axios from 'axios';

/**
 * @module Release
 */

const MAX_INT = '18446744073709551615';

/**
 * @function fetchAll
 * Fetches all releases.
 * @param {Object} [pagination = {limit: 20, offset: 0, sort: 'desc'}] Pagination options.
 * @param {Boolean} [withAccountData = false] Fetch full on-chain Release accounts.
 * @example const releases = await NinaClient.Release.fetchAll();
 */
const fetchAll = async (pagination = {}, withAccountData = false) => {
  const { limit, offset, sort } = pagination;
  return await NinaClient.get(
    '/releases',
    {
      limit: limit || 20,
      offset: offset || 0,
      sort: sort || 'desc',
    },
    withAccountData
  );
};

/**
 * @function fetch
 * @param {String} publicKey The public key of the release.
 * @param {Boolean} [withAccountData = false] Fetch full on-chain Release account.
 * @example const release = await NinaClient.Release.fetch("4dS4v5dGrUwEZmjCFu56qgyAmRfaPmns9PveWAw61rEQ");
 */
const fetch = async (publicKey, withAccountData = false) => {
  return await NinaClient.get(`/releases/${publicKey}`, undefined, withAccountData);
};

/**
 * @function fetchCollectors
 * @param {String} publicKey The public key of the release.
 * @param {Boolean} [withCollection = false] Fetch collectors collections.
 * @param {Object} [pagination = {limit, offset, sort}] Pagination options.
 * @example const collectors = await NinaClient.Release.fetchCollectors("4dS4v5dGrUwEZmjCFu56qgyAmRfaPmns9PveWAw61rEQ");
 */
const fetchCollectors = async (publicKey, withCollection = false) => {
  return await NinaClient.get(`/releases/${publicKey}/collectors${withCollection ? '?withCollection=true' : ''}`);
};

/**
 * @function fetchHubs
 * @param {String} publicKey The public key of the release.
 * @param {Boolean} [withAccountData = false] Fetch full on-chain Hub and HubRelease accounts.
 * @param {Object} [pagination = {limit, offset, sort}] Pagination options.
 * @example const hubs = await NinaClient.Release.fetchHubs("4dS4v5dGrUwEZmjCFu56qgyAmRfaPmns9PveWAw61rEQ");
 */
const fetchHubs = async (publicKey, withAccountData = false) => {
  return await NinaClient.get(`/releases/${publicKey}/hubs`, undefined, withAccountData);
};

/**
 * @function fetchExchanges
 * @param {String} publicKey The public key of the release.
 * @param {Boolean} [withAccountData = false] Fetch full on-chain Exchange accounts.
 * @param {Object} [pagination = {limit, offset, sort}] Pagination options.
 * @example const exchanges = await NinaClient.Release.fetchExchanges("4dS4v5dGrUwEZmjCFu56qgyAmRfaPmns9PveWAw61rEQ");
 */
const fetchExchanges = async (publicKey, withAccountData = false, pagination) => {
  return await NinaClient.get(`/releases/${publicKey}/exchanges`, pagination, withAccountData);
};

/**
 * @function fetchRevenueShareRecipients
 * @param {String} publicKey The public key of the release.
 * @param {Boolean} [withAccountData = false] Fetch full on-chain Release accounts.
 * @param {Object} [pagination = {limit, offset, sort}] Pagination options.
 * @example const revenueShareRecipients = await NinaClient.Release.fetchRevenueShareRecipients("4dS4v5dGrUwEZmjCFu56qgyAmRfaPmns9PveWAw61rEQ");
 */
const fetchRevenueShareRecipients = async (publicKey, withAccountData = false) => {
  return await NinaClient.get(`/releases/${publicKey}/revenueShareRecipients`, undefined, withAccountData);
};

/**
 *
 * @function purchaseViaHub
 * @param {Object} client NinaClient instance.
 * @param {String} releasePublicKey Public Key of the release.
 * @param {String} hubPublicKey Public Key of the hub.
 * @example const transactionId = await NinaClient.Release.purchaseViaHub(client, "4dS4v5dGrUwEZmjCFu56qgyAmRfaPmns9PveWAw61rEQ", "4dS4v5dGrUwEZmjCFu56qgyAmRfaPmns9PveWAw61rEQ");
 * @returns {String} the transaction ID.
 */
const purchaseViaHub = async (client, releasePublicKey, hubPublicKey) => {
  try {
    const { provider } = client;
    const program = await client.useProgram();

    releasePublicKey = new anchor.web3.PublicKey(releasePublicKey);
    hubPublicKey = new anchor.web3.PublicKey(hubPublicKey);
    const release = await program.account.release.fetch(releasePublicKey);
    let [payerTokenAccount] = await findOrCreateAssociatedTokenAccount(
      provider.connection,
      provider.wallet.publicKey,
      provider.wallet.publicKey,
      anchor.web3.SystemProgram.programId,
      anchor.web3.SYSVAR_RENT_PUBKEY,
      release.paymentMint
    );

    let [receiverReleaseTokenAccount, receiverReleaseTokenAccountIx] = await findOrCreateAssociatedTokenAccount(
      provider.connection,
      provider.wallet.publicKey,
      provider.wallet.publicKey,
      anchor.web3.SystemProgram.programId,
      anchor.web3.SYSVAR_RENT_PUBKEY,
      release.releaseMint
    );

    const hub = await program.account.hub.fetch(hubPublicKey);
    const [hubRelease] = await anchor.web3.PublicKey.findProgramAddress(
      [
        Buffer.from(anchor.utils.bytes.utf8.encode('nina-hub-release')),
        hubPublicKey.toBuffer(),
        releasePublicKey.toBuffer(),
      ],
      program.programId
    );
    const [hubContent] = await anchor.web3.PublicKey.findProgramAddress(
      [
        Buffer.from(anchor.utils.bytes.utf8.encode('nina-hub-content')),
        hubPublicKey.toBuffer(),
        releasePublicKey.toBuffer(),
      ],
      program.programId
    );

    const [hubSigner] = await anchor.web3.PublicKey.findProgramAddress(
      [Buffer.from(anchor.utils.bytes.utf8.encode('nina-hub-signer')), hubPublicKey.toBuffer()],
      program.programId
    );

    let [hubWallet] = await findOrCreateAssociatedTokenAccount(
      provider.connection,
      provider.wallet.publicKey,
      hubSigner,
      anchor.web3.SystemProgram.programId,
      anchor.web3.SYSVAR_RENT_PUBKEY,
      release.paymentMint
    );

    const instructions = [];
    const solPrice = await axios.get(`https://price.jup.ag/v1/price?id=SOL`);
    let releasePriceUi = release.price.toNumber() / Math.pow(10, 6);
    let convertAmount = releasePriceUi + (releasePriceUi * hub.referralFee.toNumber()) / 1000000;
    let usdcBalance = await getUsdcBalance(provider.wallet.publicKey, provider.connection);
    if (usdcBalance &lt; convertAmount) {
      const additionalComputeBudgetInstruction = anchor.web3.ComputeBudgetProgram.requestUnits({
        units: 400000,
        additionalFee: 0,
      });
      instructions.push(additionalComputeBudgetInstruction);
      convertAmount -= usdcBalance;
      const amt = Math.round(((convertAmount + convertAmount * 0.01) / solPrice.data.data.price) * Math.pow(10, 9));
      const { data } = await axios.get(
        `https://quote-api.jup.ag/v1/quote?inputMint=So11111111111111111111111111111111111111112&amp;outputMint=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v&amp;amount=${amt}&amp;slippage=0.5&amp;onlyDirectRoutes=true`
      );
      let transactionInstructions;
      for await (let d of data.data) {
        const transactions = await axios.post('https://quote-api.jup.ag/v1/swap', {
          route: d,
          userPublicKey: provider.wallet.publicKey.toBase58(),
        });
        if (!transactionInstructions) {
          transactionInstructions = anchor.web3.Transaction.from(
            Buffer.from(transactions.data.swapTransaction, 'base64')
          ).instructions;
        } else {
          const tx = anchor.web3.Transaction.from(Buffer.from(transactions.data.swapTransaction, 'base64'));
          let accountCount = tx.instructions.reduce((count, ix) => (count += ix.keys.length), 0);
          if (accountCount &lt; transactionInstructions.reduce((count, ix) => (count += ix.keys.length), 0)) {
            transactionInstructions = tx.instructions;
          }
        }
      }
      instructions.push(...transactionInstructions);
    }
    if (receiverReleaseTokenAccountIx) {
      instructions.push(receiverReleaseTokenAccountIx);
    }

    if (instructions.length > 0) {
      request.instructions = instructions;
    }

    const tx = await program.methods
      .releasePurchaseViaHub(release.price, decodeNonEncryptedByteArray(hub.handle))
      .accounts({
        payer: provider.wallet.publicKey,
        receiver: provider.wallet.publicKey,
        release: releasePublicKey,
        releaseSigner: release.releaseSigner,
        payerTokenAccount,
        receiverReleaseTokenAccount,
        royaltyTokenAccount: release.royaltyTokenAccount,
        releaseMint: release.releaseMint,
        hub: hubPublicKey,
        hubRelease,
        hubContent,
        hubSigner,
        hubWallet,
        tokenProgram: anchor.utils.token.TOKEN_PROGRAM_ID,
      })
      .preInstructions(instructions || [])
      .transaction();

    tx.recentBlockhash = (await provider.connection.getRecentBlockhash()).blockhash;
    tx.feePayer = provider.wallet.publicKey;
    const txid = await provider.wallet.sendTransaction(tx, provider.connection);
    await getConfirmTransaction(txid, provider.connection);

    return txid;
  } catch (error) {
    console.log(error);
    return false;
  }
};

/**
 *
 * @function releasePurchase
 * @param {Object} client NinaClient instance.
 * @param {String} releasePublicKey Public Key of the release.
 * @param {String} hubPublicKey Public Key of the hub.
 * @returns {String} Transaction Id.
 */

const releasePurchase = async (client, releasePublicKey) => {
  try {
    const { provider } = client;
    const program = await client.useProgram();
    releasePublicKey = new anchor.web3.PublicKey(releasePublicKey);
    const release = await program.account.release.fetch(releasePublicKey);
    if (release.price.toNumber === 0) {
      const message = new TextEncoder().encode(releasePublicKey.toBase58());
      const messageBase64 = encodeBase64(message);
      const signature = await provider.wallet.sign(message);
      const signatureBase64 = encodeBase64(signature);
      const response = await axios.get(
        `${process.env.NINA_IDENTITY_ENDPOINT}/collect/${releasePublicKey.toBase58()}?message=${encodeURIComponent(
          messageBase64
        )}&amp;signature=${encodeURIComponent(signatureBase64)}&amp;publicKey=${encodeURIComponent(
          provider.wallet.publicKey.toBase58()
        )}`
      );
      return response.data.txid;
    }
    let [payerTokenAccount] = await findOrCreateAssociatedTokenAccount(
      provider.connection,
      provider.wallet.publicKey,
      provider.wallet.publicKey,
      anchor.web3.SystemProgram.programId,
      anchor.web3.SYSVAR_RENT_PUBKEY,
      release.paymentMint
    );

    let [receiverReleaseTokenAccount, receiverReleaseTokenAccountIx] = await findOrCreateAssociatedTokenAccount(
      provider.connection,
      provider.wallet.publicKey,
      provider.wallet.publicKey,
      anchor.web3.SystemProgram.programId,
      anchor.web3.SYSVAR_RENT_PUBKEY,
      release.releaseMint
    );
    const instructions = [];
    if (receiverReleaseTokenAccountIx) {
      instructions.push({
        instructions: [receiverReleaseTokenAccountIx],
        cleanupInstructions: [],
        signers: [],
      });
    }
    if (client.isSol(release.paymentMint)) {
      const [wrappedSolAccount, wrappedSolInstructions] = await wrapSol(provider, release.price, release.paymentMint);
      if (!request.instructions) {
        instructions = [...wrappedSolInstructions];
      } else {
        instructions.push(...wrappedSolInstructions);
      }
      payerTokenAccount = wrappedSolAccount;
    }

    const tx = await program.methods
      .releasePurchase(release.price)
      .accounts({
        payer: provider.wallet.publicKey,
        receiver: provider.wallet.publicKey,
        release: releasePublicKey,
        releaseSigner: release.releaseSigner,
        payerTokenAccount,
        receiverReleaseTokenAccount,
        royaltyTokenAccount: release.royaltyTokenAccount,
        releaseMint: release.releaseMint,
        tokenProgram: TOKEN_PROGRAM_ID,
      })
      .preInstructions(instructions || [])
      .transaction();
    tx.recentBlockhash = (await provider.connection.getRecentBlockhash()).blockhash;
    tx.feePayer = provider.wallet.publicKey;
    const txid = await provider.wallet.sendTransaction(tx, provider.connection);
    await getConfirmTransaction(txid, provider.connection);
    return txid;
  } catch (error) {
    console.log(error);
    return false;
  }
};

/**
 *
 * @function releaseInitViaHub
 * @param {Object} client the NinaClient
 * @param {String} hubPublicKey Public Key of the hub.
 * @param {Number} retailPrice Retail price of the release.
 * @param {Number} amount Amount of the release.
 * @param {Number} resalePercentage Resale percentage of the release.
 * @param {Boolean} isUsdc Is the payment in USDC or SOL.
 * @param {String} metadataUri Metadata URI of the release.
 * @param {String} artist Artist of the release.
 * @param {String} title Title of the release.
 * @param {String} catalogNumber Catalog number of the release.
 * @param {String} release Release of the release.
 * @param {String} releaseBump Release bump of the release.
 * @param {String} releaseMint Release mint of the release.
 * @param {Boolean} isOpen Is the release open or not.
 * @returns {Object} The release.
 */

const releaseInitViaHub = async (
  client,
  hubPubkey,
  retailPrice,
  amount,
  resalePercentage,
  isUsdc = true,
  metadataUri,
  artist,
  title,
  catalogNumber,
  release,
  releaseBump,
  releaseMint,
  isOpen
) => {
  try {
    const ids = NinaClient.ids;
    const { provider } = client;
    const program = await client.useProgram();
    hubPubkey = new anchor.web3.PublicKey(hubPubkey);
    const hub = await program.account.hub.fetch(hubPubkey);
    const paymentMint = new anchor.web3.PublicKey(isUsdc ? ids.mints.usdc : ids.mints.wsol);

    const [releaseSigner, releaseSignerBump] = await anchor.web3.PublicKey.findProgramAddress(
      [release.toBuffer()],
      program.programId
    );
    const releaseMintIx = await createMintInstructions(provider, provider.wallet.publicKey, releaseMint.publicKey, 0);
    const [authorityTokenAccount, authorityTokenAccountIx] = await findOrCreateAssociatedTokenAccount(
      provider.connection,
      provider.wallet.publicKey,
      provider.wallet.publicKey,
      anchor.web3.SystemProgram.programId,
      anchor.web3.SYSVAR_RENT_PUBKEY,
      paymentMint
    );

    const [royaltyTokenAccount, royaltyTokenAccountIx] = await findOrCreateAssociatedTokenAccount(
      provider.connection,
      provider.wallet.publicKey,
      releaseSigner,
      anchor.web3.SystemProgram.programId,
      anchor.web3.SYSVAR_RENT_PUBKEY,
      paymentMint,
      true
    );

    const [hubCollaborator] = await anchor.web3.PublicKey.findProgramAddress(
      [
        Buffer.from(anchor.utils.bytes.utf8.encode('nina-hub-collaborator')),
        hubPubkey.toBuffer(),
        provider.wallet.publicKey.toBuffer(),
      ],
      program.programId
    );

    const [hubSigner] = await anchor.web3.PublicKey.findProgramAddress(
      [Buffer.from(anchor.utils.bytes.utf8.encode('nina-hub-signer')), hubPubkey.toBuffer()],
      program.programId
    );

    const [hubRelease] = await anchor.web3.PublicKey.findProgramAddress(
      [Buffer.from(anchor.utils.bytes.utf8.encode('nina-hub-release')), hubPubkey.toBuffer(), release.toBuffer()],
      program.programId
    );

    const [hubContent] = await anchor.web3.PublicKey.findProgramAddress(
      [Buffer.from(anchor.utils.bytes.utf8.encode('nina-hub-content')), hubPubkey.toBuffer(), release.toBuffer()],
      program.programId
    );

    let [hubWallet] = await findOrCreateAssociatedTokenAccount(
      provider.connection,
      provider.wallet.publicKey,
      hubSigner,
      anchor.web3.SystemProgram.programId,
      anchor.web3.SYSVAR_RENT_PUBKEY,
      paymentMint
    );

    let instructions = [...releaseMintIx, royaltyTokenAccountIx];

    if (authorityTokenAccountIx) {
      instructions.push(authorityTokenAccountIx);
    }

    const editionAmount = isOpen ? MAX_INT : amount;
    const config = {
      amountTotalSupply: new anchor.BN(editionAmount),
      amountToArtistTokenAccount: new anchor.BN(0),
      amountToVaultTokenAccount: new anchor.BN(0),
      resalePercentage: new anchor.BN(resalePercentage * 10000),
      price: new anchor.BN(uiToNative(retailPrice, paymentMint)),
      releaseDatetime: new anchor.BN(Date.now() / 1000),
    };
    const bumps = {
      release: releaseBump,
      signer: releaseSignerBump,
    };
    const metadataProgram = new anchor.web3.PublicKey(ids.programs.metaplex);
    const [metadata] = await anchor.web3.PublicKey.findProgramAddress(
      [Buffer.from('metadata'), metadataProgram.toBuffer(), releaseMint.publicKey.toBuffer()],
      metadataProgram
    );

    const nameBuf = Buffer.from(`${artist} - ${title}`.substring(0, 32));
    const nameBufString = nameBuf.slice(0, 32).toString();

    const symbolBuf = Buffer.from(catalogNumber.substring(0, 10));
    const symbolBufString = symbolBuf.slice(0, 10).toString();

    const metadataData = {
      name: nameBufString,
      symbol: symbolBufString,
      uri: metadataUri,
      sellerFeeBasisPoints: resalePercentage * 100,
    };

    const tx = await program.methods
      .releaseInitViaHub(config, bumps, metadataData, decodeNonEncryptedByteArray(hub.handle))
      .accounts({
        authority: provider.wallet.publicKey,
        release,
        releaseSigner,
        hubCollaborator,
        hub: hubPubkey,
        hubRelease,
        hubContent,
        hubSigner,
        hubWallet,
        releaseMint: releaseMint.publicKey,
        authorityTokenAccount,
        paymentMint,
        royaltyTokenAccount,
        tokenProgram: new anchor.web3.PublicKey(ids.programs.token),
        metadata,
        metadataProgram,
        systemProgram: anchor.web3.SystemProgram.programId,
        rent: anchor.web3.SYSVAR_RENT_PUBKEY,
      })
      .preInstructions(instructions)
      .transaction();
    tx.recentBlockhash = (await provider.connection.getRecentBlockhash()).blockhash;
    tx.feePayer = provider.wallet.publicKey;
    tx.partialSign(releaseMint);

    const txid = await provider.wallet.sendTransaction(tx, provider.connection);

    await getConfirmTransaction(txid, provider.connection);
    const newRelease = await Hub.fetchHubRelease(hubPubkey.toBase58(), hubRelease.toBase58());
    return newRelease;
  } catch (error) {
    console.log(error);
    return false;
  }
};

/**
 * @function initializeReleaseAndMint - Initializes a release and mints the first edition
 * @param {Object} client - the Nina Client
 * @param {*} hubPubkey - the hub pubkey
 * @example await initializeReleaseAndMint(client, hubPubkey);
 * @returns {Object} - the release, release bump, and release mint
 */

const initializeReleaseAndMint = async (client, hubPubkey) => {
  try {
    const program = await client.useProgram();
    const releaseMint = anchor.web3.Keypair.generate();
    const [release, releaseBump] = await anchor.web3.PublicKey.findProgramAddress(
      [Buffer.from(anchor.utils.bytes.utf8.encode('nina-release')), releaseMint.publicKey.toBuffer()],
      program.programId
    );
    let hubRelease;
    if (hubPubkey) {
      const [_hubRelease] = await anchor.web3.PublicKey.findProgramAddress(
        [
          Buffer.from(anchor.utils.bytes.utf8.encode('nina-hub-release')),
          new anchor.web3.PublicKey(hubPubkey).toBuffer(),
          release.toBuffer(),
        ],
        program.programId
      );
      hubRelease = _hubRelease;
    }
    return {
      release,
      releaseBump,
      releaseMint,
      hubRelease,
    };
  } catch (error) {
    console.warn(error);
    return false;
  }
};

/**
 *
 * @function releaseInit
 * @param {Object} client the NinaClient
 * @param {Number} retailPrice Retail price of the release.
 * @param {Number} amount Amount of the release.
 * @param {Number} resalePercentage Resale percentage of the release.
 * @param {String} metadataUri Metadata URI of the release.
 * @param {String} artist Artist of the release.
 * @param {String} title Title of the release.
 * @param {String} catalogNumber Catalog number of the release.
 * @param {String} metadataUri Metadata URI of the release.
 * @param {Boolean} isUsdc Is the release priced in USDC or not.
 * @param {String} release Release of the release.
 * @param {String} releaseBump Release bump of the release.
 * @param {String} releaseMint Release mint of the release.
 * @param {Boolean} isOpen Is the release open or not.
 * @returns {Object} The created Release.
 */

export const releaseInit = async (
  client,
  retailPrice,
  amount,
  resalePercentage,
  artist,
  title,
  catalogNumber,
  metadataUri,
  isUsdc = true,
  release,
  releaseBump,
  releaseMint,
  isOpen
) => {
  try {
    const ids = NinaClient.ids;
    const { provider } = client;
    const program = await client.useProgram();
    const paymentMint = new anchor.web3.PublicKey(isUsdc ? ids.mints.usdc : ids.mints.wsol);
    const publishingCreditMint = new anchor.web3.PublicKey(ids.mints.publishingCredit);

    const [releaseSigner, releaseSignerBump] = await anchor.web3.PublicKey.findProgramAddress(
      [release.toBuffer()],
      program.programId
    );

    const releaseMintIx = await createMintInstructions(provider, provider.wallet.publicKey, releaseMint.publicKey, 0);

    const [authorityTokenAccount, authorityTokenAccountIx] = await findOrCreateAssociatedTokenAccount(
      provider.connection,
      provider.wallet.publicKey,
      provider.wallet.publicKey,
      anchor.web3.SystemProgram.programId,
      anchor.web3.SYSVAR_RENT_PUBKEY,
      paymentMint
    );

    const [royaltyTokenAccount, royaltyTokenAccountIx] = await findOrCreateAssociatedTokenAccount(
      provider.connection,
      provider.wallet.publicKey,
      releaseSigner,
      anchor.web3.SystemProgram.programId,
      anchor.web3.SYSVAR_RENT_PUBKEY,
      paymentMint,
      true
    );

    const [authorityPublishingCreditTokenAccount, authorityPublishingCreditTokenAccountIx] =
      await findOrCreateAssociatedTokenAccount(
        provider.connection,
        provider.wallet.publicKey,
        provider.wallet.publicKey,
        anchor.web3.SystemProgram.programId,
        anchor.web3.SYSVAR_RENT_PUBKEY,
        publishingCreditMint
      );

    let instructions = [...releaseMintIx, royaltyTokenAccountIx];

    if (authorityTokenAccountIx) {
      instructions.push(authorityTokenAccountIx);
    }

    if (authorityPublishingCreditTokenAccountIx) {
      instructions.push(authorityPublishingCreditTokenAccountIx);
    }
    let now = new Date();
    const editionAmount = isOpen ? MAX_INT : amount;
    const config = {
      amountTotalSupply: new anchor.BN(editionAmount),
      amountToArtistTokenAccount: new anchor.BN(0),
      amountToVaultTokenAccount: new anchor.BN(0),
      resalePercentage: new anchor.BN(resalePercentage * 10000),
      price: new anchor.BN(uiToNative(retailPrice, paymentMint)),
      releaseDatetime: new anchor.BN(now.getTime() / 1000),
    };

    const metadataProgram = new anchor.web3.PublicKey(ids.programs.metaplex);
    const [metadata] = await anchor.web3.PublicKey.findProgramAddress(
      [Buffer.from('metadata'), metadataProgram.toBuffer(), releaseMint.publicKey.toBuffer()],
      metadataProgram
    );

    const nameBuf = Buffer.from(`${artist} - ${title}`.substring(0, 32));
    const nameBufString = nameBuf.slice(0, 32).toString();

    const symbolBuf = Buffer.from(catalogNumber.substring(0, 10));
    const symbolBufString = symbolBuf.slice(0, 10).toString();

    const metadataData = {
      name: nameBufString,
      symbol: symbolBufString,
      uri: metadataUri,
      sellerFeeBasisPoints: resalePercentage * 100,
    };

    const bumps = {
      release: releaseBump,
      signer: releaseSignerBump,
    };

    const tx = await program.methods
      .releaseInit(config, bumps, metadataData)
      .accounts({
        release,
        releaseSigner,
        releaseMint: releaseMint.publicKey,
        payer: provider.wallet.publicKey,
        authority: provider.wallet.publicKey,
        authorityTokenAccount: authorityTokenAccount,
        paymentMint,
        royaltyTokenAccount,
        metadata,
        metadataProgram,
        systemProgram: anchor.web3.SystemProgram.programId,
        tokenProgram: TOKEN_PROGRAM_ID,
        rent: anchor.web3.SYSVAR_RENT_PUBKEY,
      })
      .preInstructions(instructions)
      .transaction();
    tx.recentBlockhash = (await provider.connection.getRecentBlockhash()).blockhash;
    tx.feePayer = provider.wallet.publicKey;
    tx.partialSign(releaseMint);
    const txid = await provider.wallet.sendTransaction(tx, provider.connection);
    await getConfirmTransaction(txid, provider.connection);

    const createdRelease = await fetch(release.toBase58());
    return createdRelease;
  } catch (error) {
    console.warn(error);
    return false;
  }
};

/**
 * @function closeRelease
 * @param {Object} client the NinaClient
 * @param {String} releasePublicKey Public Key of the release.
 * @example await closeRelease(ninaClient, 'releasePublicKey');
 * @returns {Object} The closed Release.
 */

export const closeRelease = async (client, releasePublicKey) => {
  try {
    const { provider } = client;
    const program = await client.useProgram();
    const release = await program.account.release.fetch(new anchor.web3.PublicKey(releasePublicKey));
    const tx = await program.methods
      .releaseCloseEdition()
      .accounts({
        authority: provider.wallet.publicKey,
        release: new anchor.web3.PublicKey(releasePublicKey),
        releaseSigner: release.releaseSigner,
        releaseMint: release.releaseMint,
      })
      .transaction();
    tx.recentBlockhash = (await provider.connection.getRecentBlockhash()).blockhash;
    tx.feePayer = provider.wallet.publicKey;
    const txid = await provider.wallet.sendTransaction(tx, provider.connection);

    await getConfirmTransaction(txid, provider.connection);
    const closedRelease = await fetch(releasePublicKey);
    return closedRelease;
  } catch (error) {
    console.warn(error);
    return false;
  }
};

/**
 * @function collectRoyaltyForRelease
 * @param {Object} client the NinaClient
 * @param {String} recipient Public Key of the recipient.
 * @param {String} releasePublicKey Public Key of the release.
 * @param {Object} state the NinaClient state.
 * @example collectRoyaltyForRelease(client, recipient, releasePublicKey, state)
 * @returns {Object} the Release.
 */

export const collectRoyaltyForRelease = async (client, recipient, releasePublicKey, state) => {
  if (!releasePublicKey || !recipient) {
    return;
  }
  try {
    const { provider } = client;
    const program = await client.useProgram();

    let release;
    if (!state) {
      release = await program.account.release.fetch(new anchor.web3.PublicKey(releasePublicKey));
    } else {
      release = state.tokenData[releasePublicKey];
    }

    release.paymentMint = new anchor.web3.PublicKey(release.paymentMint);
    const [authorityTokenAccount, authorityTokenAccountIx] = await findOrCreateAssociatedTokenAccount(
      provider.connection,
      provider.wallet.publicKey,
      provider.wallet.publicKey,
      anchor.web3.SystemProgram.programId,
      anchor.web3.SYSVAR_RENT_PUBKEY,
      release.paymentMint
    );

    let instructions;
    if (authorityTokenAccountIx) {
      instructions = [authorityTokenAccountIx];
    }

    const tx = await program.methods
      .releaseRevenueShareCollect()
      .accounts({
        authority: provider.wallet.publicKey,
        authorityTokenAccount,
        release: new anchor.web3.PublicKey(releasePublicKey),
        releaseMint: release.releaseMint,
        releaseSigner: release.releaseSigner,
        royaltyTokenAccount: release.royaltyTokenAccount,
        tokenProgram: anchor.utils.token.TOKEN_PROGRAM_ID,
      })
      .preInstructions(instructions || [])
      .transaction();

    tx.recentBlockhash = (await provider.connection.getRecentBlockhash()).blockhash;
    tx.feePayer = provider.wallet.publicKey;
    const txid = await provider.wallet.sendTransaction(tx, provider.connection);
    await getConfirmTransaction(txid, provider.connection);
    const collectedRelease = await fetch(releasePublicKey);
    return collectedRelease;
  } catch (error) {
    console.warn(error);
    return false;
  }
};

/**
 * @function addRoyaltyRecipient
 * @param {Object} client - the NinaClient
 * @param {String} release - the release
 * @param {Object} updateData - the data to update the release with
 * @param {String} releasePublicKey - the Public Key of the release
 * @example addRoyaltyRecipient(client, recipient, updateData, releasePublicKey)
 * @returns {String} The Public Key of the recipient
 */

export const addRoyaltyRecipient = async (client, release, updateData, releasePublicKey) => {
  try {
    const { provider } = client;
    const program = await client.useProgram();
    const releasePubkey = new anchor.web3.PublicKey(releasePublicKey);
    if (!release) {
      release = await program.account.release.fetch(releasePubkey);
    }
    const recipientPublicKey = new anchor.web3.PublicKey(updateData.recipientAddress);
    const updateAmount = updateData.percentShare * 10000;

    let [newRoyaltyRecipientTokenAccount, newRoyaltyRecipientTokenAccountIx] = await findOrCreateAssociatedTokenAccount(
      provider.connection,
      provider.wallet.publicKey,
      recipientPublicKey,
      anchor.web3.SystemProgram.programId,
      anchor.web3.SYSVAR_RENT_PUBKEY,
      new anchor.web3.PublicKey(release.paymentMint)
    );

    let [authorityTokenAccount, authorityTokenAccountIx] = await findOrCreateAssociatedTokenAccount(
      provider.connection,
      provider.wallet.publicKey,
      provider.wallet.publicKey,
      anchor.web3.SystemProgram.programId,
      anchor.web3.SYSVAR_RENT_PUBKEY,
      new anchor.web3.PublicKey(release.paymentMint)
    );

    if (newRoyaltyRecipientTokenAccountIx) {
      request.instructions = [newRoyaltyRecipientTokenAccountIx];
    }

    if (authorityTokenAccountIx) {
      request.instructions = [authorityTokenAccountIx];
    }

    const tx = await program.methods
      .releaseRevenueShareTransfer(new anchor.BN(updateAmount))
      .accounts({
        authority: provider.wallet.publicKey,
        authorityTokenAccount,
        release: releasePublicKey,
        releaseMint: new anchor.web3.PublicKey(release.releaseMint),
        releaseSigner: new anchor.web3.PublicKey(release.releaseSigner),
        royaltyTokenAccount: release.royaltyTokenAccount,
        newRoyaltyRecipient: recipientPublicKey,
        newRoyaltyRecipientTokenAccount,
        tokenProgram: TOKEN_PROGRAM_ID,
        rent: anchor.web3.SYSVAR_RENT_PUBKEY,
      })
      .transaction();
    tx.recentBlockhash = (await provider.connection.getRecentBlockhash()).blockhash;
    tx.feePayer = provider.wallet.publicKey;
    const txid = await provider.wallet.sendTransaction(tx, provider.connection);
    await getConfirmTransaction(txid, provider.connection);
    return recipientPublicKey;
  } catch (error) {
    console.warn(error);
    return false;
  }
};

export default {
  fetchAll,
  fetch,
  fetchCollectors,
  fetchHubs,
  fetchExchanges,
  fetchRevenueShareRecipients,
  purchaseViaHub,
  releaseInitViaHub,
  initializeReleaseAndMint,
  releasePurchase,
  releaseInit,
  closeRelease,
  collectRoyaltyForRelease,
  addRoyaltyRecipient,
};
</code></pre></article></section></div></div></div><div class="search-container" id="PkfLWpAbet" style="display:none"><div class="wrapper" id="iCxFxjkHbP"><button class="icon-button search-close-button" id="VjLlGakifb" aria-label="close search"><svg><use xlink:href="#close-icon"></use></svg></button><div class="search-box-c"><svg><use xlink:href="#search-icon"></use></svg> <input type="text" id="vpcKVYIppa" class="search-input" placeholder="Search..." autofocus></div><div class="search-result-c" id="fWwVHRuDuN"><span class="search-result-c-text">Type anything to view search result</span></div></div></div><div class="mobile-menu-icon-container"><button class="icon-button" id="mobile-menu" data-isopen="false" aria-label="menu"><svg><use xlink:href="#menu-icon"></use></svg></button></div><div id="mobile-sidebar" class="mobile-sidebar-container"><div class="mobile-sidebar-wrapper"><a href="/" class="sidebar-title sidebar-title-anchor">@nina-protocol/js-sdk</a><div class="mobile-nav-links"></div><div class="mobile-sidebar-items-c"><div class="sidebar-section-title with-arrow" data-isopen="false" id="_0O3YiuusVCU80BYexLu_"><div>Modules</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="module-Account.html">Account</a></div><div class="sidebar-section-children"><a href="module-Exchange.html">Exchange</a></div><div class="sidebar-section-children"><a href="module-Hub.html">Hub</a></div><div class="sidebar-section-children"><a href="module-Post.html">Post</a></div><div class="sidebar-section-children"><a href="module-Release.html">Release</a></div><div class="sidebar-section-children"><a href="module-Search.html">Search</a></div><div class="sidebar-section-children"><a href="module-Subscription.html">Subscription</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="XQXdyJUZGv6LEeZCNU6PL"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="NinaClient.html">NinaClient</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="15ZawdpG98m0aRc5WmjbQ"><div>Global</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="global.html#init">init</a></div></div></div><div class="mobile-navbar-actions"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div></div></div><script type="text/javascript" src="scripts/core.min.js"></script><script src="scripts/search.min.js" defer="defer"></script><script src="scripts/third-party/fuse.js" defer="defer"></script><script type="text/javascript">var tocbotInstance=tocbot.init({tocSelector:"#eed4d2a0bfd64539bb9df78095dec881",contentSelector:".main-content",headingSelector:"h1, h2, h3",hasInnerContainers:!0,scrollContainer:".main-content",headingsOffset:130,onClick:bringLinkToView})</script></body></html>